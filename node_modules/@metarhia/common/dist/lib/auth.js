'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require = require('./iterator'),
    iter = _require.iter;

var unicodeCategories = require('./unicode-categories');

var NUMBERS_RANGE = [[49, 57]];
var SPECIAL_CHARS_RANGE = [[32, 47], [58, 64], [91, 96], [123, 126]]; // https://www.owasp.org/index.php/Password_special_characters

var UTF16_SINGLE_UNIT = 1 << 16;

var unicodeRangesIncludes = function unicodeRangesIncludes(ranges, codePoint) {
  var left = 0;
  var right = ranges.length - 1;

  while (left <= right) {
    var mid = left + right >>> 1;
    var value = ranges[mid];

    if (typeof value === 'number') {
      if (codePoint > value) left = mid + 1;else if (codePoint < value) right = mid - 1;else return true;
    } else if (codePoint > value[1]) {
      left = mid + 1;
    } else if (codePoint < value[0]) {
      right = mid - 1;
    } else {
      return true;
    }
  }

  return false;
};

var stringIncludesChars = function stringIncludesChars(str, ranges, charsNumber) {
  var number = 0;

  for (var index = 0; index <= str.length - (charsNumber - number); index++) {
    var codePoint = str.codePointAt(index);
    if (codePoint >= UTF16_SINGLE_UNIT) index++;

    if (unicodeRangesIncludes(ranges, codePoint) && ++number === charsNumber) {
      return true;
    }
  }

  return false;
};

var isNotTopology = function isNotTopology(str, topologies) {
  var topology = '';

  for (var index = 0; index < str.length; index++) {
    var codePoint = str.codePointAt(index);
    if (codePoint >= UTF16_SINGLE_UNIT) index++;

    if (unicodeRangesIncludes(unicodeCategories.Lu, codePoint)) {
      topology += 'u';
    } else if (unicodeRangesIncludes(unicodeCategories.Ll, codePoint)) {
      topology += 'l';
    } else if (unicodeRangesIncludes(NUMBERS_RANGE, codePoint)) {
      topology += 'd';
    } else {
      topology += 's';
    }
  }

  return !iter(topologies).includes(topology);
};

var passwordTests = {
  MIN_LENGTH: {
    test: function test(password, options) {
      return password.length >= options.minLength;
    },
    hint: function hint(options) {
      return {
        name: 'MIN_LENGTH',
        minLength: options.minLength
      };
    },
    options: {
      minLength: 10
    }
  },
  MAX_LENGTH: {
    test: function test(password, options) {
      return password.length <= options.maxLength;
    },
    hint: function hint(options) {
      return {
        name: 'MAX_LENGTH',
        maxLength: options.maxLength
      };
    },
    options: {
      maxLength: 128
    }
  },
  MIN_PASSPHRASE_LENGTH: {
    test: function test(password, options) {
      return password.length >= options.minLength;
    },
    hint: function hint(options) {
      return {
        name: 'MIN_PASSPHRASE_LENGTH',
        minLength: options.minLength
      };
    },
    options: {
      minLength: 20
    }
  },
  MAX_REPEATED_CHARS: {
    test: function test(password, options) {
      var regexp = new RegExp("(.)\\1{".concat(options.number, ",}"));
      return !regexp.test(password);
    },
    hint: function hint(options) {
      return {
        name: 'MAX_REPEATED_CHARS',
        number: options.number
      };
    },
    options: {
      number: 2
    }
  },
  MIN_LOWERCASE_CHARS: {
    test: function test(password, option) {
      return stringIncludesChars(password, unicodeCategories.Ll, option.number);
    },
    hint: function hint(options) {
      return {
        name: 'MIN_LOWERCASE_CHARS',
        number: options.number
      };
    },
    options: {
      number: 1
    }
  },
  MIN_UPPERCASE_CHARS: {
    test: function test(password, options) {
      return stringIncludesChars(password, unicodeCategories.Lu, options.number);
    },
    hint: function hint(options) {
      return {
        name: 'MIN_UPPERCASE_CHARS',
        number: options.number
      };
    },
    options: {
      number: 1
    }
  },
  MIN_NUMBERS: {
    test: function test(password, options) {
      return stringIncludesChars(password, NUMBERS_RANGE, options.number);
    },
    hint: function hint(options) {
      return {
        name: 'MIN_NUMBERS',
        number: options.number
      };
    },
    options: {
      number: 1
    }
  },
  MIN_SPECIAL_CHARS: {
    test: function test(password, options) {
      return stringIncludesChars(password, SPECIAL_CHARS_RANGE, options.number);
    },
    hint: function hint(options) {
      return {
        name: 'MIN_SPECIAL_CHARS',
        number: options.number
      };
    },
    options: {
      number: 1
    }
  },
  FOUND_TOPOLOGY: {
    test: function test(password, options) {
      return isNotTopology(password, options.topologies);
    },
    hint: function hint() {
      return {
        name: 'FOUND_TOPOLOGY'
      };
    }
  },
  POPULAR_PASSWORD: {
    test: function test(password, options) {
      return !iter(options.popularPasswords).includes(password);
    },
    hint: function hint() {
      return {
        name: 'POPULAR_PASSWORD'
      };
    }
  }
};
var loginTests = {
  MIN_LENGTH: {
    test: function test(login, options) {
      return login.length >= options.minLength;
    },
    hint: function hint(options) {
      return {
        name: 'MIN_LENGTH',
        minLength: options.minLength
      };
    },
    options: {
      minLength: 6
    }
  },
  MAX_LENGTH: {
    test: function test(login, options) {
      return login.length <= options.maxLength;
    },
    hint: function hint(options) {
      return {
        name: 'MAX_LENGTH',
        maxLength: options.maxLength
      };
    },
    options: {
      maxLength: 50
    }
  },
  IS_EMAIL: {
    test: function test(login) {
      var EMAIL_REGEXP = new RegExp("^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(" + '?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$');
      var MAX_DOMAIN_LENGTH = 255;
      var MAX_LOCAL_PART_LENGTH = 64;

      if (login.includes('@')) {
        var _login$split = login.split('@'),
            _login$split2 = _slicedToArray(_login$split, 2),
            localPart = _login$split2[0],
            domain = _login$split2[1];

        return domain.length <= MAX_DOMAIN_LENGTH && localPart.length <= MAX_LOCAL_PART_LENGTH && EMAIL_REGEXP.test(login);
      }

      return false;
    },
    hint: function hint() {
      return {
        name: 'IS_EMAIL'
      };
    }
  }
};
var loginPasswordTests = {
  LOGIN_INCLUDES_PASSWORD: {
    test: function test(login, password) {
      return !login.includes(password);
    },
    hint: function hint() {
      return {
        name: 'LOGIN_INCLUDES_PASSWORD'
      };
    }
  },
  PASSWORD_INCLUDES_LOGIN: {
    test: function test(login, password) {
      return !password.includes(login);
    },
    hint: function hint() {
      return {
        name: 'PASSWORD_INCLUDES_LOGIN'
      };
    }
  }
};

var AuthenticationStrength = // AuthenticationStrength constructor
//   valid - <boolean>
//   hints - <Object>
//     required - <Array>
//     optional - <Array>
//   compliance - <number>, ratio of passed optional tests
//                to all optional tests
function AuthenticationStrength(valid, hints, compliance) {
  _classCallCheck(this, AuthenticationStrength);

  this.valid = valid;
  this.hints = hints;
  this.compliance = compliance;
}; // Function that checks the arguments on a test suite
// Signature: tests, required, optional, ...testArgs
//   tests - <Array>, of password/login tests
//   required - <Array>, required tests configs
//   optional - <Array>, optional tests configs
//   testArgs - <Array>, [password] / [login] / [login, password]
// Returns: <AuthenticationStrength>


var makeTest = function makeTest(tests, required, optional) {
  for (var _len = arguments.length, testArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    testArgs[_key - 3] = arguments[_key];
  }

  var test = function test(testsConfig) {
    var testsHints = [];
    testsConfig.forEach(function (testConfig) {
      var _ref = typeof testConfig === 'string' ? [testConfig, {}] : [testConfig.name, testConfig],
          _ref2 = _slicedToArray(_ref, 2),
          testName = _ref2[0],
          userOptions = _ref2[1];

      var _tests$testName = tests[testName],
          test = _tests$testName.test,
          hint = _tests$testName.hint,
          _tests$testName$optio = _tests$testName.options,
          options = _tests$testName$optio === void 0 ? {} : _tests$testName$optio;

      var testOptions = _objectSpread(_objectSpread({}, options), userOptions);

      if (!test.apply(void 0, testArgs.concat([testOptions]))) testsHints.push(hint(testOptions));
    });
    return testsHints;
  };

  var requiredHints = test(required);
  var optionalHints = test(optional);
  var valid = !requiredHints.length;
  var compliance = optional.length ? 1 - optionalHints.length / optional.length : 1;
  var hints = {
    required: requiredHints,
    optional: optionalHints
  };
  return new AuthenticationStrength(valid, hints, compliance);
}; // Function that tests the login
// Signature: login, required[, optional]
//   login - <string>, login to test
//   required - <Array>, required tests configs
//   optional - <Array>, optional tests configs, defalult: `[]`
// Returns: <AuthenticationStrength>


var checkLogin = function checkLogin(login, required) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (!required) {
    required = ['MIN_LENGTH', 'MAX_LENGTH'];
  }

  return makeTest(loginTests, required, optional, login);
}; // Function that tests the password
// Signature: password, required[, optional]
//   password - <string>, password to test
//   required - <Array>, required tests configs
//   optional - <Array>, optional tests configs, default: `[]`
// Returns: <AuthenticationStrength>


var checkPassword = function checkPassword(password, required) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (!required) {
    required = ['MIN_LENGTH', 'MAX_LENGTH'];
    optional = ['MIN_NUMBERS', 'MIN_SPECIAL_CHARS', 'MIN_UPPERCASE_CHARS', 'MIN_LOWERCASE_CHARS'];
  }

  return makeTest(passwordTests, required, optional, password);
}; // Function that tests the login with password
// Signature: login, password, required[, optional]
//   login - <string>, login to test
//   password - <string>, password to test
//   required - <Array>, required tests configs
//   optional - <Array>, optional tests configs, default: `[]`
// Returns: <AuthenticationStrength>


var checkLoginPassword = function checkLoginPassword(login, password, required) {
  var optional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  if (!required) {
    required = ['PASSWORD_INCLUDES_LOGIN', 'LOGIN_INCLUDES_PASSWORD'];
  }

  return makeTest(loginPasswordTests, required, optional, login, password);
};

module.exports = {
  checkLogin: checkLogin,
  checkPassword: checkPassword,
  checkLoginPassword: checkLoginPassword
};