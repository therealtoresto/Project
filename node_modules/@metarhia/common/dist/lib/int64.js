'use strict'; // The value is assigned at the end of the file to avoid the circular reference.

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Uint64 = null;
var INT32_MAX = 0x7fffffff;
var UINT32_MAX = 0xffffffff;
var charToNum = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};

var Int64 = /*#__PURE__*/function () {
  function Int64(value) {
    _classCallCheck(this, Int64);

    this.value = new Uint32Array(2);

    if (value instanceof Int64 || value instanceof Uint64) {
      this.value[0] = value.value[0];
      this.value[1] = value.value[1];
      return;
    }

    var numValue = Number(value);
    if (Number.isNaN(numValue)) return;

    if (numValue >= 0 && numValue <= UINT32_MAX) {
      this.value[0] = numValue;
    } else if (numValue >= -INT32_MAX && numValue < 0) {
      this.value[0] = numValue;
      this.value[1] = UINT32_MAX;
    } else if (numValue >= 0 && numValue <= Number.MAX_SAFE_INTEGER) {
      this.value[0] = numValue % (UINT32_MAX + 1);
      this.value[1] = Math.floor(numValue / (UINT32_MAX + 1));
    } else if (numValue >= Number.MIN_SAFE_INTEGER && numValue < 0) {
      this.value[0] = -numValue % (UINT32_MAX + 1);
      this.value[1] = Math.floor(-numValue / (UINT32_MAX + 1));
      this.value = Int64._conversion(this.value);
    } else if (typeof value === 'string') {
      var negative = value.startsWith('-');
      if (negative) value = value.slice(1);
      var radix = 10;

      if (value.startsWith('0x')) {
        radix = 16;
      } else if (value.startsWith('0o')) {
        radix = 8;
      } else if (value.startsWith('0b')) {
        radix = 2;
      }

      if (radix !== 10) value = value.slice(2);
      var intRadix = new Int64(radix);
      var res = Int64.zero();

      for (var i = 0; i < value.length; i++) {
        var digit = charToNum[value[i]];
        var intDigit = new Int64(digit);
        res = Int64.mult(res, intRadix);
        if (negative) res.sub(intDigit);else res.add(intDigit);
      }

      this.value[0] = res.value[0];
      this.value[1] = res.value[1];
    }
  }

  _createClass(Int64, [{
    key: "toInt32",
    value: function toInt32() {
      return this.value[0] >> 0;
    }
  }, {
    key: "toUint32",
    value: function toUint32() {
      return this.value[0];
    }
  }, {
    key: "add",
    value: function add(b) {
      if (b.value[0] === 0 && b.value[1] === 0) return this;
      var tmp = this.value[0] + b.value[0];
      this.value[0] = tmp;
      this.value[1] += b.value[1] + (tmp > UINT32_MAX ? 1 : 0);
      return this;
    }
  }, {
    key: "sub",
    value: function sub(b) {
      if (b.value[0] === 0 && b.value[1] === 0) return this;

      var value = Int64._conversion(b.value);

      var tmp = this.value[0] + value[0];
      this.value[0] = tmp;
      this.value[1] += value[1] + (tmp > UINT32_MAX ? 1 : 0);
      return this;
    }
  }, {
    key: "and",
    value: function and(b) {
      this.value[0] &= b.value[0];
      this.value[1] &= b.value[1];
      return this;
    }
  }, {
    key: "or",
    value: function or(b) {
      this.value[0] |= b.value[0];
      this.value[1] |= b.value[1];
      return this;
    }
  }, {
    key: "not",
    value: function not() {
      this.value[0] = ~this.value[0];
      this.value[1] = ~this.value[1];
      return this;
    }
  }, {
    key: "xor",
    value: function xor(b) {
      this.value[0] ^= b.value[0];
      this.value[1] ^= b.value[1];
      return this;
    }
  }, {
    key: "shiftRightLogical",
    value: function shiftRightLogical(b) {
      b %= 64;

      if (b >= 32) {
        this.value[0] = this.value[1] >>> b - 32;
        this.value[1] = 0;
        return this;
      }

      var mask = (1 << b) - 1;
      var tr = (this.value[1] & mask) << 32 - b;
      this.value[1] >>>= b;
      this.value[0] = this.value[0] >>> b | tr;
      return this;
    }
  }, {
    key: "shiftRightArithmetic",
    value: function shiftRightArithmetic(b) {
      b %= 64;
      var negative = this.value[1] >>> 31;

      if (b >= 32) {
        this.value[0] = this.value[1] >>> b - 32;

        if (negative) {
          var mask = (1 << b) - 1;
          this.value[0] |= mask << 32 - b;
          this.value[1] = 0xffffffff;
        } else {
          this.value[1] = 0;
        }
      } else {
        var _mask = (1 << b) - 1;

        var tr = (this.value[1] & _mask) << 32 - b;
        this.value[0] = this.value[0] >>> b | tr;
        this.value[1] >>= b;
      }

      return this;
    }
  }, {
    key: "shiftRight",
    value: function shiftRight(b) {
      return this.shiftRightArithmetic(b);
    }
  }, {
    key: "shiftLeft",
    value: function shiftLeft(b) {
      b %= 64;

      if (b >= 32) {
        this.value[1] = this.value[0] << b - 32;
        this.value[0] = 0;
        return this;
      }

      var mask = (1 << b) - 1 << 32 - b;
      var tr = (this.value[0] & mask) >>> 32 - b;
      this.value[0] <<= b;
      this.value[1] = this.value[1] << b | tr;
      return this;
    }
  }, {
    key: "inc",
    value: function inc() {
      return this.add(Int64.one());
    }
  }, {
    key: "dec",
    value: function dec() {
      return this.sub(Int64.one());
    }
  }, {
    key: "toString",
    value: function toString() {
      var radix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      var negative = this.value[1] >>> 31;

      if (radix < 2 || radix > 36) {
        throw new RangeError('toString() radix argument must be between 2 and 36');
      }

      var digitStr = '0123456789abcdefghijklmnopqrstuvwxyz';
      var result = '';

      if (radix === 2 || radix === 16) {
        var num = new Int64(this);
        if (negative) num.value = Int64._conversion(num.value);
        var value = num.value[0];

        while (value !== 0) {
          result = digitStr[value % radix] + result;
          value = Math.floor(value / radix);
        }

        value = num.value[1];

        if (value !== 0) {
          var pad = radix === 2 ? '00000000000000000000000000000000' : '00000000';
          result = (pad + result).slice(-pad.length);
        }

        while (value !== 0) {
          result = digitStr[value % radix] + result;
          value = Math.floor(value / radix);
        }

        if (result.length === 0) {
          result = '0';
        }

        if (negative) result = '-' + result;
        return result;
      }

      if (negative) {
        var uvalue = new Uint64();
        uvalue.value = Int64._conversion(this.value);
        return '-' + uvalue.toString(radix);
      } else {
        var zero = Int64.zero();

        var _value = new Int64(this);

        var uintRadix = new Int64(radix);

        while (Int64.cmp(_value, zero) !== 0) {
          var digit = Int64.mod(_value, uintRadix).value[0];
          result = digitStr[digit] + result;
          _value = Int64.div(_value, uintRadix);
        }

        if (result.length === 0) result = '0';
      }

      return result;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }
  }, {
    key: "toPostgres",
    value: function toPostgres() {
      return this.toString();
    }
  }], [{
    key: "zero",
    value: function zero() {
      return new Int64(0);
    }
  }, {
    key: "one",
    value: function one() {
      return new Int64(1);
    } // #private
    // Convert signed to 2's complement representation and vise versa

  }, {
    key: "_conversion",
    value: function _conversion(value) {
      var result = new Uint32Array(value);
      var pos = 0;

      if (result[0] === 0) {
        while (pos < 32 && (result[1] >>> pos & 1) === 0) {
          pos++;
        }

        if (pos !== 31) {
          var mask = (1 << pos + 1) - 1;
          result[1] = ~(result[1] | mask) | result[1] & mask;
        }
      } else {
        while (pos < 32 && (result[0] >>> pos & 1) === 0) {
          pos++;
        }

        if (pos !== 31) {
          var _mask2 = (1 << pos + 1) - 1;

          result[0] = ~(result[0] | _mask2) | result[0] & _mask2;
        }

        result[1] = ~result[1];
      }

      return result;
    }
  }, {
    key: "add",
    value: function add(a, b) {
      return new Int64(a).add(b);
    }
  }, {
    key: "sub",
    value: function sub(a, b) {
      return new Int64(a).sub(b);
    }
  }, {
    key: "cmp",
    value: function cmp(a, b) {
      var aSign = a.value[1] >>> 31;
      var bSign = b.value[1] >>> 31;
      if (aSign !== bSign) return aSign === 1 ? -1 : 1;
      if (a.value[1] > b.value[1]) return 1;
      if (a.value[1] < b.value[1]) return -1;
      if (a.value[0] === b.value[0]) return 0;
      return a.value[0] > b.value[0] ? 1 : -1;
    } // #private

  }, {
    key: "_division",
    value: function _division(n, d) {
      var zero = Int64.zero();
      var one = Int64.one();

      if (Int64.cmp(d, zero) === 0) {
        throw new RangeError('Int64: division by zero');
      }

      if (Int64.cmp(n, zero) === 0) return [zero, 0];
      if (Int64.cmp(d, one) === 0) return [n, zero];
      if (Int64.cmp(d, n) === 0) return [one, zero];
      var nSign = n.value[1] >>> 31;
      var value = new Uint32Array(n.value);
      if (nSign) value = Int64._conversion(value);
      var dSign = d.value[1] >>> 31;
      var dPositive = new Int64(d);
      if (dSign) dPositive.value = Int64._conversion(dPositive.value);
      var q = Int64.zero();
      var r = Int64.zero();

      for (var i = 63; i >= 0; i--) {
        r.shiftLeft(1);
        var valIndex = i >>> 5;
        var nval = value[valIndex];
        var ii = i < 32 ? i : i - 32;
        r.value[0] = r.value[0] & ~1 | (nval & 1 << ii) >>> ii;

        if (Int64.cmp(r, dPositive) >= 0) {
          r.sub(dPositive);
          q.value[valIndex] |= 1 << ii;
        }
      }

      q.value[1] &= INT32_MAX;
      r.value[1] &= INT32_MAX;
      if (nSign ^ dSign) q.value = Int64._conversion(q.value);
      if (nSign) r.value = Int64._conversion(r.value);
      return [q, r];
    }
  }, {
    key: "div",
    value: function div(a, b) {
      return Int64._division(a, b)[0];
    }
  }, {
    key: "mod",
    value: function mod(a, b) {
      return Int64._division(a, b)[1];
    }
  }, {
    key: "mult",
    value: function mult(a, b) {
      var zero = Int64.zero();
      var one = Int64.one();
      if (Int64.cmp(a, zero) === 0 || Int64.cmp(b, zero) === 0) return zero;
      if (Int64.cmp(a, one) === 0) return new Int64(b);
      if (Int64.cmp(b, one) === 0) return new Int64(a);
      var aSign = a.value[1] >>> 31;
      var bSign = b.value[1] >>> 31;
      var result = Int64.zero();
      var aPositive = new Int64(a);
      var value = new Uint32Array(b.value);
      if (aSign) aPositive.value = Int64._conversion(aPositive.value);
      if (bSign) value = Int64._conversion(value);

      for (var i = 0; i < 63; i++) {
        var valIndex = i >= 32 ? 1 : 0;

        if (value[valIndex] & 1) {
          result.add(new Int64(aPositive).shiftLeft(i));
        }

        value[valIndex] >>>= 1;
      }

      if (aSign ^ bSign) result.value = Int64._conversion(result.value);
      return result;
    }
  }, {
    key: "and",
    value: function and(a, b) {
      return new Int64(a).and(b);
    }
  }, {
    key: "or",
    value: function or(a, b) {
      return new Int64(a).or(b);
    }
  }, {
    key: "not",
    value: function not(a) {
      return new Int64(a).not();
    }
  }, {
    key: "xor",
    value: function xor(a, b) {
      return new Int64(a).xor(b);
    }
  }, {
    key: "shiftRight",
    value: function shiftRight(a, b) {
      return new Int64(a).shiftRight(b);
    }
  }, {
    key: "shiftLeft",
    value: function shiftLeft(a, b) {
      return new Int64(a).shiftLeft(b);
    }
  }]);

  return Int64;
}();

module.exports = {
  Int64: Int64
};

var _require = require('./uint64');

Uint64 = _require.Uint64;
_require;