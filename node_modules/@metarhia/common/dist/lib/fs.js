'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var fs = require('fs');

var pathModule = require('path');

var util = require('util');

var _require = require('./iterator'),
    iter = _require.iter;

var MKDIRP_DEFAULT_MODE = 511;

var mkdir = function mkdir(dir, mode, cb) {
  fs.access(dir, fs.constants.F_OK, function (err) {
    if (err && err.code === 'ENOENT') {
      mkdir(pathModule.dirname(dir), mode, function (err) {
        if (err) cb(err);else fs.mkdir(dir, mode, cb);
      });
    } else {
      cb(err);
    }
  });
};

var recursivelyListDirs = function recursivelyListDirs(dir) {
  var list = [dir];
  var nextDir = dir;
  var root = pathModule.parse(dir).root || '.';

  while ((nextDir = pathModule.dirname(nextDir)) !== root) {
    list.push(nextDir);
  }

  return list;
};

var rmdirp = function rmdirp(dir, cb) {
  var dirs = recursivelyListDirs(dir);
  var i = 0;
  rmNextDir();

  function rmNextDir() {
    fs.rmdir(dirs[i], function (err) {
      if (err) {
        cb(err);
        return;
      }

      if (++i === dirs.length) {
        cb();
      } else {
        rmNextDir();
      }
    });
  }
};

var mkdirp;
var version = process.versions.node.split('.').map(function (el) {
  return parseInt(el);
});

if (version[0] < 10 || version[0] === 10 && version[1] <= 11) {
  mkdirp = function mkdirp(dir, mode, cb) {
    if (typeof mode === 'function') {
      cb = mode;
      mode = MKDIRP_DEFAULT_MODE;
    }

    mkdir(dir, mode, cb);
  };
} else {
  mkdirp = function mkdirp(dir, mode, cb) {
    typeof mode === 'function' ? fs.mkdir(dir, {
      recursive: true
    }, mode) : fs.mkdir(dir, {
      recursive: true,
      mode: mode
    }, cb);
  };
}

var isNotDirectoryError = function isNotDirectoryError(err) {
  return err.code === 'ENOTDIR' || process.platform === 'win32' && err.code === 'ENOENT';
}; // Recursively remove directory
//   path <string> path to a file or directory to be removed
//   callback <Function> callback


var rmRecursive = function rmRecursive(path, callback) {
  fs.readdir(path, function (err, files) {
    if (err) {
      if (isNotDirectoryError(err)) fs.unlink(path, callback);else callback(err);
      return;
    }

    if (files.length === 0) {
      fs.rmdir(path, callback);
      return;
    }

    var errored = false;
    var counter = files.length;

    var cb = function cb(err) {
      if (errored) return;

      if (err) {
        errored = true;
        callback(err);
      } else if (--counter === 0) {
        fs.rmdir(path, callback);
      }
    };

    files.forEach(function (f) {
      return rmRecursive(pathModule.join(path, f), cb);
    });
  });
}; // TODO(SemenchenkoVitaliy): remove and use `fs.promises` instead when
// Node.js 8 is dropped


var fsPromises;

if (fs.promises) {
  fsPromises = fs.promises;
} else {
  fsPromises = iter(['readdir', 'rmdir', 'unlink', 'mkdir', 'access']).collectWith({}, function (obj, name) {
    obj[name] = util.promisify(fs[name]);
  });
} // Recursively remove directory
//   path <string> path to a file or directory to be removed
// Returns: <Promise>


var rmRecursivePromise = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(path) {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", fsPromises.readdir(path).then( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(files) {
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return Promise.all(files.map(function (f) {
                          return rmRecursivePromise(pathModule.join(path, f));
                        }));

                      case 2:
                        return _context.abrupt("return", fsPromises.rmdir(path));

                      case 3:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x2) {
                return _ref2.apply(this, arguments);
              };
            }(), function (err) {
              if (isNotDirectoryError(err)) return fsPromises.unlink(path);
              throw err;
            }));

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function rmRecursivePromise(_x) {
    return _ref.apply(this, arguments);
  };
}();

var mkdirPromise = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(dir, mode) {
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", fsPromises.access(dir).then(function () {
              return Promise.resolve();
            }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return mkdirPromise(pathModule.dirname(dir), mode);

                    case 2:
                      return _context3.abrupt("return", fsPromises.mkdir(dir, mode));

                    case 3:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }))));

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function mkdirPromise(_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
}();

var mkdirpPromise;

if (fs.promises) {
  mkdirpPromise = function mkdirpPromise(dir) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MKDIRP_DEFAULT_MODE;
    return fs.promises.mkdir(dir, {
      recursive: true,
      mode: mode
    });
  };
} else {
  mkdirpPromise = function mkdirpPromise(dir) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MKDIRP_DEFAULT_MODE;
    return mkdirPromise(dir, mode);
  };
}

module.exports = {
  mkdirp: mkdirp,
  mkdirpPromise: mkdirpPromise,
  rmdirp: rmdirp,
  rmRecursive: rmRecursive,
  rmRecursivePromise: rmRecursivePromise
};